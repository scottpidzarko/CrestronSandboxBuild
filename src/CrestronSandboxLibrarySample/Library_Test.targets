<?xml version="1.0" encoding="utf-8" ?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0" >
  <PropertyGroup>
    <!-- force the use of the older csc to ensure output will be the same. MSBuild happily can target the right version of net framework/compact framework 
    when configured but newer compilers introduce non-sandbox compatible optimizations -->
	  <CscToolPath>C:\Windows\Microsoft.NET\Framework\v3.5</CscToolPath>
	  <CscToolExe>csc.exe</CscToolExe>
    <FrameworkRegistryBase>Software\Microsoft\.NETCompactFramework</FrameworkRegistryBase>
    <AssemblyFoldersSuffix>$(PlatformFamilyName)\AssemblyFoldersEx</AssemblyFoldersSuffix>
    <AssemblyFoldersExConditions>,OSVersion=$(OSVersion):Platform=$(PlatformID)</AssemblyFoldersExConditions>
    <TargetCompactFramework>true</TargetCompactFramework>
    <ArchiveExtension>.clz</ArchiveExtension>
  </PropertyGroup>
  <Target Name="SimplSharpClean" AfterTargets="AfterClean">
    <Delete Files="$(OutputPath)\ProgramInfo.config" ContinueOnError="true" />
    <Delete Files="$(OutputPath)\$(TargetName)$(ArchiveExtension)" ContinueOnError="true" />
  </Target>
  <Target Name="SimplSharpPostProcess" BeforeTargets="AfterBuild">
    <GetAssemblyIdentity AssemblyFiles="$(TargetPath)">
      <Output TaskParameter="Assemblies" ItemName="Assembly" />
    </GetAssemblyIdentity>
    <!-- from the MSBuild documentation -->
    <!-- OutputPath = relative output directory, no trailing slash eg. bin\Debug -->
    <!-- TargetName = name of assembly-->
    <!-- TargetPath	= The absolute path name of the primary output file for the build (defined as drive + path + base name + file extension) -->
    <!-- $(ProjectDir)	The directory of the project (defined as drive + path); includes the trailing backslash '\'. -->
    <PostProcess programInfoFilename="$(OutputPath)\ProgramInfo.config" targetPath="$(TargetPath)" targetName="$(TargetName)" packagePath="$(MSBuildThisFileDirectory)" outputPath="$(OutputPath)" archiveFilename="$(TargetName)$(ArchiveExtension)" excludeTargets="$(MSBuildThisFileFullPath)" references="@(_ResolveAssemblyReferenceResolvedFiles)" assemblyVersion="%(Assembly.Version)" />
    <DoCrestronSigning programInfoFilename="$(OutputPath)\ProgramInfo.config" targetPath="$(TargetPath)" targetName="$(TargetName)" packagePath="$(MSBuildThisFileDirectory)" outputPath="$(OutputPath)" archiveFilename="$(TargetName)$(ArchiveExtension)" excludeTargets="$(MSBuildThisFileFullPath)" references="@(_ResolveAssemblyReferenceResolvedFiles)" assemblyVersion="%(Assembly.Version)" projectDir="$(ProjectDir)" targetDir="$(TargetDir)"/>    
  </Target>
  <UsingTask TaskName="DoCrestronSigning" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup>
      <programInfoFilename ParameterType="System.String" Required="true" />
      <targetPath ParameterType="System.String" Required="true" />
      <targetName ParameterType="System.String" Required="true" />
      <packagePath ParameterType="System.String" Required="true" />
      <outputPath ParameterType="System.String" Required="true" />
      <archiveFilename ParameterType="System.String" Required="true" />
      <excludeTargets ParameterType="System.String" Required="true" />
      <references ParameterType="System.String" Required="true" />
      <assemblyVersion ParameterType="System.String" Required="true" />
      <projectDir ParameterType="System.String" Required="true" />
      <targetDir ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="C:\Program Files (x86)\Crestron\Simpl#\Crestron.SIMPLSharp.dll" />
      <Reference Include="Crestron.CmVptCOM.interop" />
      <Reference Include="Crestron.VptCOMServer.interop" />
      <Reference Include="EnvDTE" />
      <Reference Include="EnvDTE" />
      <Reference Include="Microsoft.VisualStudio.OLE.Interop" />
      <Reference Include="Microsoft.VisualStudio.Shell.9.0" />
      <Reference Include="Microsoft.VisualStudio.Shell.Interop" />
      <Reference Include="Microsoft.VisualStudio.Shell.Interop.8.0" />
      <Reference Include="Microsoft.VisualStudio.Shell.Interop.9.0, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
      <Reference Include="System" />
      <Reference Include="System.Core" />
      <Reference Include="System.Design" />
      <Reference Include="System.Drawing" />
      <Reference Include="System.Windows.Forms" />
      <Reference Include="System.Xml" />
      <Reference Include="System.Xml.Linq" />
      <Reference Include="VSLangProj" />
      <Reference Include="VSLangProj80" />      
      <Reference Include="C:\Program Files (x86)\Crestron\Simpl#\Crestron.Tools.SIMPLSharp.Services.dll" />
      <Reference Include="C:\Program Files (x86)\Crestron\Simpl#\Interop.CAPICOM.dll" />
      <Reference Include="C:\Program Files (x86)\Crestron\Simpl#\Mono.Cecil.DLL" />
      <Reference Include="C:\Program Files (x86)\Crestron\Simpl#\Mono.Cecil.Pdb.DLL" />
      <Reference Include="C:\Program Files (x86)\Crestron\Simpl#\Newtonsoft.Json.DLL" />
      <Reference Include="C:\Program Files (x86)\Crestron\Simpl#\SimplSharpCustomAttributesInterface.DLL" />
      <Reference Include="System.Linq" />
      <Reference Include="System.Reflection" />
      <Reference Include="System.IO" />
      <Reference Include="System.Xml" />
      <Using Namespace="Crestron.SIMPLSharp.VsPlugin" />
      <Using Namespace="Crestron.Tools.SIMPLSharp.Services" />
      <Using Namespace="System.Linq" />
      <Using Namespace="System.Reflection" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Xml" />    
      <Code Type="Fragment" Language="cs">
        <![CDATA[			                  
			  try
			  {				          
					// ************ This starts the part for signing the dlls with the crestron plugin ****************
          // Constants setup
          string logfolder = @"\SIMPLSharpLogs";
          string datapath = @"C:\Program Files (x86)\Crestron\Cresdb\Programming";
          bool refreshSDK = true;
          
					string path = projectDir.Remove(projectDir.Length - 1, 1); // docs say this has no trailing slash, but it appears it really does. We don't want the trailing slash for the plugin
          string logpath = path + logfolder;
          
					string absoluteOutputPath = targetDir;
					string fullAssemblyName = targetPath;
					string compiledFileName = archiveFilename;
					string archiveFullName = Path.Combine(absoluteOutputPath, compiledFileName);
          
          // setup the SIMPLSharp service
					var bf = BindingFlags.NonPublic | BindingFlags.Instance;
					SIMPLSharpPackage p = new SIMPLSharpPackage();
					Type t = p.GetType();
					var method = t.GetMethod("d", bf);
					method.Invoke(p, null);
					var data = t.GetProperty("ProviderConfig", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(p, null);					

					var s = new SIMPLSharpService(data, targetName, path, logpath, refreshSDK, datapath);					
			
					// these three fields are set up outside of making the simpl sharp service for some reason
					if (s.ProjectInfo.CompiledFilename == null)
					{
						s.ProjectInfo.CompiledFilename = archiveFullName;
					}
					if(s.ProjectInfo.ProgramIdTag == null)
					{
						s.ProjectInfo.ProgramIdTag = targetName;
					}
					if (s.ProjectInfo.SystemName == null)
					{
						s.ProjectInfo.SystemName = targetName;
					}
					if (s.ProjectInfo.MinimumFirmwareVersion == null)
					{
						s.SetMinimumFirmwareVersion("1.007.0017"); // TODO figure out how to systematically generate this?
					}
					
					//SDK resources not set by the SIMPLSharpProject class or any decendants
					//set by SIMPLSharpPackage			
					// the vsplugin builds this by comparing the project references with the list of sdkassemblies from SimplSharp service 
					// and the system assemblies from simplsharp service, and the deprecated assemblies from simplsharp service
					IList<ReferenceInfo> projectReferences = new List<ReferenceInfo>(); // TODO add code to generate this. For the televic example it doesn't have extra references so this is blank

					// I can't remember what the purpose of the result of this was in the actual plugin. TODO determine what to do with the result here - tests didn't use the result
					s.ReconcileProjectReferences(projectReferences);
					// I can't remember what the purpose of the result of this was in the actual plugin. TODO determine what to do with the result here - tests didn't use the result
					s.IsAssemblyVerified(fullAssemblyName);

					IList<string> resolutionPaths = new List<string>
					{
						absoluteOutputPath,
						SIMPLSharpService.SDKPath
					};
					// string passed is the full assembly name, which we get from Simplsharp project FullAssemblyName
					// for generateDebugSysmbols, we *may* have to set this to false in order to get Mono.Cecil to like the pdb format
          // TODO determine if we need to true/false and if that can depend on the project debug/release configuratino
					var result1 = s.ValidateAssembly(fullAssemblyName, resolutionPaths, false);
					if (!result1.IsValid)
					{
						StringBuilder sb = new StringBuilder();
            
						foreach (var error in result1.Errors)
						{
							sb.Append(String.Format("Sandbox validation error: {0}\r\n", error));
						}
						throw new Exception(sb.ToString());            
					}

					//string passed is the full assembly name, which we get from Simplsharp project FullAssemblyName
					var result2 = s.VerifyAssembly(fullAssemblyName);
					if (!result2)
					{
						throw new Exception("Assembly could not be verified by S# plugin.");
					}

					//Create a list of dependency info
					var dependencies = new List<ReferenceInfo>(); // list of all files in the output path that have a .dll or .exe extension that isn't FullAssemblyName
					List<string> source = new List<string>
					{
						".dll",
						".exe"
					};
					string[] filesInDirectory = Directory.GetFiles(absoluteOutputPath, "*.*", SearchOption.AllDirectories);
					foreach (var text in filesInDirectory)
					{
						if (source.Contains(Path.GetExtension(text), StringComparer.OrdinalIgnoreCase) && text != fullAssemblyName)
						{
							ReferenceInfo item = new ReferenceInfo
							{
								CopyLocal = true,
								Filename = text, // full assembly name for file - dll or exe, ie. @"C:\Users\Username\OtherDirs\ProjecDir\bin\Debug\Newtonsoft.Json.Compact.dll"
								ReferenceType = ReferenceType.Assembly,
								IsVerified = true
							};
							dependencies.Add(item);
						}
					}

					// list of everything in the output path that doesn't have .info, .pdb, .config, .clz, .cplz, .cpz, .dll, and .exe? Unsure if it actually does that, it builds a list of that and never returns it.
					// list of everything in the SimplSharpProject's SDK resources enumerator then gets copied to the output path and also added to this list
					var references = new List<string>();
					foreach (ResourceFileInfo resourceFileInfo in SIMPLSharpService.SDKResources)
					{
						if (!references.Contains(resourceFileInfo.Filename, StringComparer.OrdinalIgnoreCase))
						{
							string text = Path.Combine(absoluteOutputPath, resourceFileInfo.Filename);
							File.Copy(resourceFileInfo.Fullname, text, true);
							references.Add(text);
						}
					}

					Console.WriteLine("Creating project manifest");
					s.CreateManifest(fullAssemblyName, compiledFileName, dependencies, references);
          
          IList<string> ListOfDllsInProjectInfo;
					// I think the below is how the plugin does it.
					ListOfDllsInProjectInfo = SIMPLSharpService.SystemAssemblies
						.Select(x => x.Filename)
						.Distinct()
						.ToList<string>();

					/*s.CreateArchive(
						absoluteOutputPath,
						ListOfDllsInProjectInfo,
						archiveFullName); */

					return true;
				
				}
				catch (Exception ex)
				{
					Log.LogErrorFromException(ex);
					return false;
				}
				
				]]>
      </Code>
    </Task>
  </UsingTask>
  <UsingTask TaskName="PostProcess" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup>
      <programInfoFilename ParameterType="System.String" Required="true" />
      <targetPath ParameterType="System.String" Required="true" />
      <targetName ParameterType="System.String" Required="true" />
      <packagePath ParameterType="System.String" Required="true" />
      <outputPath ParameterType="System.String" Required="true" />
      <archiveFilename ParameterType="System.String" Required="true" />
      <excludeTargets ParameterType="System.String" Required="true" />
      <references ParameterType="System.String" Required="true" />
      <assemblyVersion ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.IO" />
      <Reference Include="System.IO.Compression" />
      <Reference Include="System.Xml" />
      <Reference Include="System.Globalization" />
      <Reference Include="System.Text.RegularExpressions" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.IO.Compression" />
      <Using Namespace="System.Xml" />
      <Using Namespace="System.Globalization" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[			                  
			  try
			  {
					if(references.Contains("SimplSharpPro.exe;"))
          {
						return true;
          }
                      				
					var version = string.Empty;
					var parts = packagePath.Split(Path.DirectorySeparatorChar);
					for(int i = parts.Length - 1; i > 0; i--)
					{
						var part = parts[i];
						var mc = Regex.Matches(part, @"\d+(\.\d+)+");
						if(mc.Count > 0) 
						{
							version =  mc[0].Value;
							break;
						}		
					}

					var xmlDoc = new XmlDocument();
					var root = xmlDoc.CreateElement("ProgramInfo");
					xmlDoc.AppendChild(root);

					var required = xmlDoc.CreateElement("RequiredInfo");
					root.AppendChild(required);

					var node = xmlDoc.CreateElement("FriendlyName");
					node.AppendChild(xmlDoc.CreateTextNode(targetName.Length >  20 ? targetName.Substring(0,20) : targetName));
					required.AppendChild(node);	

					node = xmlDoc.CreateElement("SystemName");
					node.AppendChild(xmlDoc.CreateTextNode(targetName));
					required.AppendChild(node);	

					node = xmlDoc.CreateElement("EntryPoint");
					node.AppendChild(xmlDoc.CreateTextNode(targetName));
					required.AppendChild(node);	

					node = xmlDoc.CreateElement("DesignToolId");
					node.AppendChild(xmlDoc.CreateTextNode("6"));
					required.AppendChild(node);	

					node = xmlDoc.CreateElement("ProgramToolId");
					node.AppendChild(xmlDoc.CreateTextNode("6"));
					required.AppendChild(node);	


					FileInfo fileInfo = new FileInfo(targetPath);

					var optional = xmlDoc.CreateElement("OptionalInfo");
					root.AppendChild(optional);

					node = xmlDoc.CreateElement("CompiledOn");
					node.AppendChild(xmlDoc.CreateTextNode(fileInfo.LastWriteTime.ToString("yyyy-MM-dd'T'HH:mm:ss.fffzzz", DateTimeFormatInfo.InvariantInfo)));
					optional.AppendChild(node);

					node = xmlDoc.CreateElement("CompilerRev");
					node.AppendChild(xmlDoc.CreateTextNode(assemblyVersion));
					optional.AppendChild(node);

					var plugin = xmlDoc.CreateElement("Plugin");
					root.AppendChild(plugin);
		
					node = xmlDoc.CreateElement("Include4.dat");
					node.AppendChild(xmlDoc.CreateTextNode(version));
					plugin.AppendChild(node);
						
					xmlDoc.Save(programInfoFilename);		
					          
					string archiveName = Path.Combine(outputPath, archiveFilename);
					if(File.Exists(archiveName))
						File.Delete(archiveName);
				  
					using (Stream zipStream = new FileStream(Path.GetFullPath(archiveName), FileMode.Create, FileAccess.Write))
					using (ZipArchive archive = new ZipArchive(zipStream, ZipArchiveMode.Create))
					{
						var outputFiles = Directory.GetFiles(outputPath, "*.*", SearchOption.AllDirectories);
						var copyOnvif = File.Exists(Path.Combine(outputPath, "SimplSharpOnvifInterface.dll"));
						//var packageFiles = Directory.GetFiles(packagePath, "*.*", SearchOption.AllDirectories);	
						var files = new string[outputFiles.Length]; //+ packageFiles.Length];
						outputFiles.CopyTo(files, 0);
						//packageFiles.CopyTo(files, outputFiles.Length);	
							
						foreach (var filename in files)
						{
							if(filename.Equals(archiveName,StringComparison.OrdinalIgnoreCase) ||
							   filename.Equals(excludeTargets,StringComparison.OrdinalIgnoreCase) ||
							   (Path.GetFileName(filename).Equals("CrestronOnvif.dll", StringComparison.OrdinalIgnoreCase) && !copyOnvif))
								continue;


								using (Stream fileStream = new FileStream(filename, FileMode.Open, FileAccess.Read))
								using (Stream fileStreamInZip = archive.CreateEntry(filename.Replace(outputPath, null).Replace(packagePath, null)).Open())
									fileStream.CopyTo(fileStreamInZip);
						}
					}

					return true;
				}
				catch (Exception ex)
				{
					Log.LogError(ex.StackTrace);
					Log.LogErrorFromException(ex);
					return false;
				}
				
				]]>
      </Code>
    </Task>
  </UsingTask>
  <Import Project="C:\Windows\Microsoft.NET\Framework\v3.5\Microsoft.CSharp.Targets" />
  <Import Project="C:\Windows\Microsoft.NET\Framework\v3.5\Microsoft.CompactFramework.Common.targets" />
</Project>